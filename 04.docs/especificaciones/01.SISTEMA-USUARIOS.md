# Sistema de Usuarios y Autenticación

> **Spec ID**: SPEC-001  
> **Versión**: 1.0  
> **Estado**: ✅ Aprobada  
> **Fecha**: 2026-02-01

---

## 1. Resumen

Sistema de gestión de usuarios con autenticación JWT y control de acceso basado en roles (RBAC).

**Roles**:
- `ADMIN`: Administrador del sistema
- `CASAL`: Responsable de una falla
- `USUARIO`: Usuario regular

---

## 2. Modelo de Datos

### 2.1 Entidad Usuario

```sql
CREATE TABLE usuarios (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellidos VARCHAR(100) NOT NULL,
    rol VARCHAR(20) NOT NULL CHECK (rol IN ('ADMIN', 'CASAL', 'USUARIO')),
    activo BOOLEAN DEFAULT true,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ultima_sesion TIMESTAMP,
    
    CONSTRAINT email_formato CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

CREATE INDEX idx_usuarios_email ON usuarios(email);
CREATE INDEX idx_usuarios_rol ON usuarios(rol);
```

### 2.2 Entidad JPA (Java)

```java
@Entity
@Table(name = "usuarios")
public class Usuario {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 255)
    @Email(message = "Email debe tener formato válido")
    private String email;
    
    @Column(name = "password_hash", nullable = false, length = 255)
    private String passwordHash;
    
    @Column(nullable = false, length = 100)
    @NotBlank(message = "Nombre no puede estar vacío")
    private String nombre;
    
    @Column(nullable = false, length = 100)
    @NotBlank(message = "Apellidos no pueden estar vacíos")
    private String apellidos;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private Rol rol;
    
    @Column(nullable = false)
    private Boolean activo = true;
    
    @Column(name = "fecha_registro")
    @CreationTimestamp
    private LocalDateTime fechaRegistro;
    
    @Column(name = "ultima_sesion")
    private LocalDateTime ultimaSesion;
    
    // Getters, Setters, Constructor
}
```

### 2.3 Enum Rol

```java
public enum Rol {
    ADMIN("Administrador"),
    CASAL("Casal"),
    USUARIO("Usuario");
    
    private final String descripcion;
    
    Rol(String descripcion) {
        this.descripcion = descripcion;
    }
    
    public String getDescripcion() {
        return descripcion;
    }
}
```

---

## 3. DTOs (Data Transfer Objects)

### 3.1 DTO de Respuesta

```java
public class UsuarioDTO {
    private Long id;
    private String email;
    private String nombre;
    private String apellidos;
    private Rol rol;
    private Boolean activo;
    private LocalDateTime fechaRegistro;
    
    // Constructor, Getters, Setters
}
```

### 3.2 Request de Registro

```java
public class RegistroRequest {
    
    @NotBlank(message = "Email es obligatorio")
    @Email(message = "Email debe tener formato válido")
    private String email;
    
    @NotBlank(message = "Contraseña es obligatoria")
    @Size(min = 8, message = "Contraseña debe tener mínimo 8 caracteres")
    private String password;
    
    @NotBlank(message = "Nombre es obligatorio")
    @Size(max = 100, message = "Nombre no puede exceder 100 caracteres")
    private String nombre;
    
    @NotBlank(message = "Apellidos son obligatorios")
    @Size(max = 100, message = "Apellidos no pueden exceder 100 caracteres")
    private String apellidos;
    
    // Por defecto, nuevos usuarios son USUARIO
    // Solo ADMIN puede crear usuarios con otros roles
    
    // Getters, Setters
}
```

### 3.3 Request de Login

```java
public class LoginRequest {
    
    @NotBlank(message = "Email es obligatorio")
    @Email(message = "Email debe tener formato válido")
    private String email;
    
    @NotBlank(message = "Contraseña es obligatoria")
    private String password;
    
    // Getters, Setters
}
```

### 3.4 Response de Login

```java
public class LoginResponse {
    private String token;
    private String tipo = "Bearer"; // Tipo de token
    private UsuarioDTO usuario;
    
    // Constructor, Getters, Setters
}
```

---

## 4. Endpoints API

### 4.1 POST /api/auth/registrar
Registra un nuevo usuario.

**Request**:
```json
{
  "email": "usuario@example.com",
  "password": "miContraseña123",
  "nombre": "Juan",
  "apellidos": "García Pérez"
}
```

**Response exitosa (201 Created)**:
```json
{
  "id": 123,
  "email": "usuario@example.com",
  "nombre": "Juan",
  "apellidos": "García Pérez",
  "rol": "USUARIO",
  "activo": true,
  "fechaRegistro": "2026-02-01T10:30:00"
}
```

**Errores posibles**:
- `400 Bad Request`: Datos de entrada inválidos
- `409 Conflict`: Email ya registrado

### 4.2 POST /api/auth/login
Autentica un usuario y devuelve un token JWT.

**Request**:
```json
{
  "email": "usuario@example.com",
  "password": "miContraseña123"
}
```

**Response exitosa (200 OK)**:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "tipo": "Bearer",
  "usuario": {
    "id": 123,
    "email": "usuario@example.com",
    "nombre": "Juan",
    "apellidos": "García Pérez",
    "rol": "USUARIO",
    "activo": true
  }
}
```

**Errores posibles**:
- `401 Unauthorized`: Credenciales incorrectas
- `403 Forbidden`: Usuario desactivado

### 4.3 GET /api/usuarios/perfil
Obtiene el perfil del usuario autenticado.

**Headers**:
```
Authorization: Bearer {token}
```

**Response exitosa (200 OK)**:
```json
{
  "id": 123,
  "email": "usuario@example.com",
  "nombre": "Juan",
  "apellidos": "García Pérez",
  "rol": "USUARIO",
  "activo": true,
  "fechaRegistro": "2026-02-01T10:30:00"
}
```

**Errores posibles**:
- `401 Unauthorized`: Token inválido o expirado

### 4.4 PUT /api/usuarios/perfil
Actualiza el perfil del usuario autenticado.

**Headers**:
```
Authorization: Bearer {token}
```

**Request**:
```json
{
  "nombre": "Juan Carlos",
  "apellidos": "García López"
}
```

**Response exitosa (200 OK)**:
```json
{
  "id": 123,
  "email": "usuario@example.com",
  "nombre": "Juan Carlos",
  "apellidos": "García López",
  "rol": "USUARIO",
  "activo": true
}
```

**Nota**: No se puede cambiar email ni rol por esta vía.

### 4.5 GET /api/usuarios (Solo ADMIN)
Lista todos los usuarios.

**Headers**:
```
Authorization: Bearer {token_admin}
```

**Query Params**:
- `rol` (opcional): Filtrar por rol
- `activo` (opcional): true/false

**Response exitosa (200 OK)**:
```json
{
  "contenido": [
    {
      "id": 123,
      "email": "usuario@example.com",
      "nombre": "Juan",
      "apellidos": "García",
      "rol": "USUARIO",
      "activo": true
    },
    ...
  ],
  "total": 50
}
```

### 4.6 PUT /api/usuarios/{id} (Solo ADMIN)
Actualiza cualquier usuario (incluyendo rol).

**Headers**:
```
Authorization: Bearer {token_admin}
```

**Request**:
```json
{
  "nombre": "Juan Carlos",
  "apellidos": "García López",
  "rol": "CASAL",
  "activo": true
}
```

**Response exitosa (200 OK)**:
```json
{
  "id": 123,
  "email": "usuario@example.com",
  "nombre": "Juan Carlos",
  "apellidos": "García López",
  "rol": "CASAL",
  "activo": true
}
```

---

## 5. Lógica de Negocio (Service)

### 5.1 UsuarioService

```java
@Service
public class UsuarioService {
    
    private static final Logger log = LoggerFactory.getLogger(UsuarioService.class);
    
    private final UsuarioRepository usuarioRepository;
    private final PasswordEncoder passwordEncoder;
    
    public UsuarioService(UsuarioRepository usuarioRepository, 
                          PasswordEncoder passwordEncoder) {
        this.usuarioRepository = usuarioRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    /**
     * Registra un nuevo usuario con rol USUARIO por defecto.
     */
    public UsuarioDTO registrar(RegistroRequest request) {
        // Validar que el email no exista
        if (usuarioRepository.existsByEmail(request.getEmail())) {
            throw new DuplicateEntityException("Email ya registrado: " + request.getEmail());
        }
        
        // Crear entidad Usuario
        Usuario usuario = new Usuario();
        usuario.setEmail(request.getEmail());
        usuario.setPasswordHash(passwordEncoder.encode(request.getPassword()));
        usuario.setNombre(request.getNombre());
        usuario.setApellidos(request.getApellidos());
        usuario.setRol(Rol.USUARIO); // Por defecto
        usuario.setActivo(true);
        
        // Guardar
        Usuario guardado = usuarioRepository.save(usuario);
        
        log.info("Usuario registrado: id={}, email={}", guardado.getId(), guardado.getEmail());
        
        return convertirADTO(guardado);
    }
    
    /**
     * Autentica un usuario y devuelve información básica.
     * El token JWT se genera en el controlador.
     */
    public Usuario autenticar(String email, String password) {
        Usuario usuario = usuarioRepository.findByEmail(email)
            .orElseThrow(() -> new UnauthorizedException("Credenciales incorrectas"));
        
        if (!usuario.getActivo()) {
            throw new ForbiddenException("Usuario desactivado");
        }
        
        if (!passwordEncoder.matches(password, usuario.getPasswordHash())) {
            throw new UnauthorizedException("Credenciales incorrectas");
        }
        
        // Actualizar última sesión
        usuario.setUltimaSesion(LocalDateTime.now());
        usuarioRepository.save(usuario);
        
        log.info("Usuario autenticado: id={}, email={}", usuario.getId(), usuario.getEmail());
        
        return usuario;
    }
    
    /**
     * Obtiene un usuario por su ID.
     */
    public UsuarioDTO obtenerPorId(Long id) {
        Usuario usuario = usuarioRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado: " + id));
        
        return convertirADTO(usuario);
    }
    
    /**
     * Lista todos los usuarios (solo para ADMIN).
     */
    public List<UsuarioDTO> listarTodos(Rol rolFiltro, Boolean activoFiltro) {
        List<Usuario> usuarios;
        
        if (rolFiltro != null && activoFiltro != null) {
            usuarios = usuarioRepository.findByRolAndActivo(rolFiltro, activoFiltro);
        } else if (rolFiltro != null) {
            usuarios = usuarioRepository.findByRol(rolFiltro);
        } else if (activoFiltro != null) {
            usuarios = usuarioRepository.findByActivo(activoFiltro);
        } else {
            usuarios = usuarioRepository.findAll();
        }
        
        return usuarios.stream()
            .map(this::convertirADTO)
            .collect(Collectors.toList());
    }
    
    /**
     * Actualiza perfil del usuario autenticado.
     */
    public UsuarioDTO actualizarPerfil(Long usuarioId, String nombre, String apellidos) {
        Usuario usuario = usuarioRepository.findById(usuarioId)
            .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado"));
        
        usuario.setNombre(nombre);
        usuario.setApellidos(apellidos);
        
        Usuario actualizado = usuarioRepository.save(usuario);
        
        log.info("Perfil actualizado: id={}", usuarioId);
        
        return convertirADTO(actualizado);
    }
    
    /**
     * Actualiza cualquier usuario (solo ADMIN).
     */
    public UsuarioDTO actualizarUsuario(Long id, String nombre, String apellidos, 
                                         Rol rol, Boolean activo) {
        Usuario usuario = usuarioRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado: " + id));
        
        usuario.setNombre(nombre);
        usuario.setApellidos(apellidos);
        usuario.setRol(rol);
        usuario.setActivo(activo);
        
        Usuario actualizado = usuarioRepository.save(usuario);
        
        log.info("Usuario actualizado por ADMIN: id={}, rol={}", id, rol);
        
        return convertirADTO(actualizado);
    }
    
    private UsuarioDTO convertirADTO(Usuario usuario) {
        UsuarioDTO dto = new UsuarioDTO();
        dto.setId(usuario.getId());
        dto.setEmail(usuario.getEmail());
        dto.setNombre(usuario.getNombre());
        dto.setApellidos(usuario.getApellidos());
        dto.setRol(usuario.getRol());
        dto.setActivo(usuario.getActivo());
        dto.setFechaRegistro(usuario.getFechaRegistro());
        return dto;
    }
}
```

---

## 6. Configuración Spring Security

### 6.1 SecurityConfig

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    private final JwtAuthenticationFilter jwtAuthFilter;
    
    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter) {
        this.jwtAuthFilter = jwtAuthFilter;
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .cors().and()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/fallas/**").permitAll() // Lectura pública
                .requestMatchers("/api/eventos/**").permitAll() // Lectura pública
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/usuarios/**").authenticated()
                .anyRequest().authenticated()
            )
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

## 7. JWT - Generación y Validación

### 7.1 JwtService

```java
@Service
public class JwtService {
    
    @Value("${jwt.secret}")
    private String secretKey;
    
    @Value("${jwt.expiration:86400000}") // 24 horas por defecto
    private Long expiracion;
    
    /**
     * Genera un token JWT para un usuario.
     */
    public String generarToken(Usuario usuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("rol", usuario.getRol().name());
        claims.put("nombre", usuario.getNombre());
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(usuario.getEmail())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiracion))
            .signWith(SignatureAlgorithm.HS256, secretKey)
            .compact();
    }
    
    /**
     * Extrae el email del usuario desde el token.
     */
    public String extraerEmail(String token) {
        return extraerClaim(token, Claims::getSubject);
    }
    
    /**
     * Valida que el token sea válido y no haya expirado.
     */
    public boolean validarToken(String token, UserDetails userDetails) {
        final String email = extraerEmail(token);
        return (email.equals(userDetails.getUsername()) && !tokenExpirado(token));
    }
    
    private boolean tokenExpirado(String token) {
        return extraerExpiracion(token).before(new Date());
    }
    
    private Date extraerExpiracion(String token) {
        return extraerClaim(token, Claims::getExpiration);
    }
    
    private <T> T extraerClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extraerTodasLasClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extraerTodasLasClaims(String token) {
        return Jwts.parser()
            .setSigningKey(secretKey)
            .parseClaimsJws(token)
            .getBody();
    }
}
```

---

## 8. Pruebas

### 8.1 Prueba de Integración - Registro

```java
@SpringBootTest
@AutoConfigureMockMvc
public class UsuarioIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    public void registrarUsuario_DatosValidos_Exitoso() throws Exception {
        RegistroRequest request = new RegistroRequest();
        request.setEmail("nuevo@example.com");
        request.setPassword("password123");
        request.setNombre("Nuevo");
        request.setApellidos("Usuario");
        
        mockMvc.perform(post("/api/auth/registrar")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.email").value("nuevo@example.com"))
            .andExpect(jsonPath("$.rol").value("USUARIO"));
    }
    
    @Test
    public void registrarUsuario_EmailDuplicado_Conflicto() throws Exception {
        // Primero registrar un usuario
        RegistroRequest request = new RegistroRequest();
        request.setEmail("duplicado@example.com");
        request.setPassword("password123");
        request.setNombre("Test");
        request.setApellidos("Usuario");
        
        mockMvc.perform(post("/api/auth/registrar")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated());
        
        // Intentar registrar con el mismo email
        mockMvc.perform(post("/api/auth/registrar")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isConflict());
    }
}
```

---

## 9. Configuración

### 9.1 application.properties

```properties
# JWT Configuration
jwt.secret=tu-clave-secreta-muy-larga-y-segura-cambiar-en-produccion
jwt.expiration=86400000

# BCrypt (rounds)
spring.security.bcrypt.strength=10
```

---

## 10. Consideraciones de Seguridad

### 10.1 Contraseñas
- ✅ Siempre hasheadas con BCrypt (nunca almacenar en texto plano)
- ✅ Mínimo 8 caracteres
- ✅ Nunca devolver password_hash en respuestas API

### 10.2 Tokens JWT
- ✅ Expiración de 24 horas
- ✅ Clave secreta fuerte (cambiar en producción)
- ✅ No almacenar información sensible en el payload
- ✅ Validar en cada petición

### 10.3 Endpoints
- ✅ CORS configurado apropiadamente
- ✅ Validación de entrada en todos los endpoints
- ✅ Rate limiting (opcional, recomendado para producción)

---

> **Nota**: Esta especificación debe ser la referencia para cualquier implementación relacionada con usuarios y autenticación.
