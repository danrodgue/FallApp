# üêõ Registro de Errores y Soluciones

> **Spec ID**: MOBILE-004  
> **Versi√≥n**: 1.0  
> **Fecha**: 2026-02-01  
> **Prop√≥sito**: Documentar errores encontrados y sus soluciones para referencia futura

---

## üìã √çndice

1. [C√≥mo usar este documento](#c√≥mo-usar-este-documento)
2. [Plantilla de Error](#plantilla-de-error)
3. [Errores Resueltos](#errores-resueltos)
4. [Errores Conocidos Pendientes](#errores-conocidos-pendientes)
5. [Patrones de Error Comunes](#patrones-de-error-comunes)

---

## C√≥mo usar este documento

### Al encontrar un error:
1. Busca primero si ya existe una soluci√≥n documentada
2. Si no existe, docum√©ntalo usando la plantilla
3. Una vez resuelto, actualiza con la soluci√≥n

### Al resolver un error:
1. Documenta la causa ra√≠z
2. Incluye el c√≥digo antes/despu√©s
3. A√±ade c√≥mo prevenir en el futuro

### B√∫squeda r√°pida:
- Usa `Ctrl+F` para buscar por:
  - Mensaje de error
  - Nombre de clase/archivo
  - Categor√≠a de error

---

## Plantilla de Error

```markdown
### ERR-XXX: [T√≠tulo descriptivo]

**Fecha**: YYYY-MM-DD  
**Categor√≠a**: [NETWORK | ROOM | COMPOSE | COROUTINES | DI | NAVIGATION | BUILD | OTHER]  
**Severidad**: [CRITICAL | HIGH | MEDIUM | LOW]  
**Estado**: [üî¥ ABIERTO | üü¢ RESUELTO]

#### Descripci√≥n del problema
[Qu√© est√° fallando y en qu√© contexto]

#### Mensaje de error
\`\`\`
[Stacktrace o mensaje de error]
\`\`\`

#### Causa ra√≠z
[Por qu√© ocurre este error]

#### C√≥digo problem√°tico
\`\`\`kotlin
// C√≥digo que causa el error
\`\`\`

#### Soluci√≥n
\`\`\`kotlin
// C√≥digo corregido
\`\`\`

#### Pasos para reproducir
1. [Paso 1]
2. [Paso 2]
3. [Paso 3]

#### C√≥mo prevenir en el futuro
- [Medida preventiva 1]
- [Medida preventiva 2]

#### Referencias
- [Links a documentaci√≥n, issues, etc.]
```

---

## Errores Resueltos

### ERR-001: Ejemplo - Cleartext HTTP no permitido en Android

**Fecha**: 2026-02-01  
**Categor√≠a**: NETWORK  
**Severidad**: HIGH  
**Estado**: üü¢ RESUELTO

#### Descripci√≥n del problema
La app no puede conectarse a la API en `http://35.180.21.42:8080` porque Android bloquea tr√°fico HTTP no seguro por defecto.

#### Mensaje de error
```
java.io.IOException: Cleartext HTTP traffic to 35.180.21.42 not permitted
```

#### Causa ra√≠z
A partir de Android 9 (API 28), el tr√°fico HTTP cleartext est√° bloqueado por defecto por razones de seguridad.

#### C√≥digo problem√°tico
```xml
<!-- AndroidManifest.xml sin configuraci√≥n de network security -->
<application
    android:name=".FallAppApplication"
    ...>
```

#### Soluci√≥n
```xml
<!-- AndroidManifest.xml -->
<application
    android:name=".FallAppApplication"
    android:usesCleartextTraffic="true"
    ...>
```

**Alternativa m√°s segura** (para producci√≥n):
```xml
<!-- res/xml/network_security_config.xml -->
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">35.180.21.42</domain>
    </domain-config>
</network-security-config>

<!-- AndroidManifest.xml -->
<application
    android:networkSecurityConfig="@xml/network_security_config"
    ...>
```

#### C√≥mo prevenir en el futuro
- Siempre configurar `network_security_config.xml` al iniciar proyecto
- En producci√≥n, usar HTTPS exclusivamente
- Documentar la IP del servidor en `ApiConfig.kt`

---

### ERR-002: Ejemplo - Room no encuentra TypeConverter

**Fecha**: 2026-02-01  
**Categor√≠a**: ROOM  
**Severidad**: MEDIUM  
**Estado**: üü¢ RESUELTO

#### Descripci√≥n del problema
Room no puede serializar/deserializar campos de tipo `LocalDateTime` o `List<String>`.

#### Mensaje de error
```
error: Cannot figure out how to save this field into database. 
You can consider adding a type converter for it.
```

#### Causa ra√≠z
Room solo soporta tipos primitivos por defecto. Tipos complejos requieren TypeConverters.

#### C√≥digo problem√°tico
```kotlin
@Entity(tableName = "fallas")
data class FallaEntity(
    @PrimaryKey val id: Long,
    val nombre: String,
    val fechaCreacion: LocalDateTime,  // ‚ùå No soportado
    val imagenes: List<String>          // ‚ùå No soportado
)
```

#### Soluci√≥n
```kotlin
// database/Converters.kt
class Converters {
    private val json = Json { ignoreUnknownKeys = true }
    
    @TypeConverter
    fun fromLocalDateTime(value: LocalDateTime?): Long? {
        return value?.atZone(ZoneId.systemDefault())?.toInstant()?.toEpochMilli()
    }
    
    @TypeConverter
    fun toLocalDateTime(value: Long?): LocalDateTime? {
        return value?.let {
            LocalDateTime.ofInstant(
                Instant.ofEpochMilli(it),
                ZoneId.systemDefault()
            )
        }
    }
    
    @TypeConverter
    fun fromStringList(value: List<String>?): String? {
        return value?.let { json.encodeToString(it) }
    }
    
    @TypeConverter
    fun toStringList(value: String?): List<String>? {
        return value?.let { json.decodeFromString(it) }
    }
}

// FallAppDatabase.kt
@Database(entities = [FallaEntity::class], version = 1)
@TypeConverters(Converters::class)  // ‚úÖ Registrar converters
abstract class FallAppDatabase : RoomDatabase() {
    abstract fun fallaDao(): FallaDao
}
```

#### C√≥mo prevenir en el futuro
- Crear `Converters.kt` al inicio del proyecto
- Documentar qu√© tipos requieren conversi√≥n
- A√±adir nuevos converters cuando se usen tipos no primitivos

---

### ERR-003: Ejemplo - Koin no encuentra dependencia

**Fecha**: 2026-02-01  
**Categor√≠a**: DI  
**Severidad**: HIGH  
**Estado**: üü¢ RESUELTO

#### Descripci√≥n del problema
Al inyectar un ViewModel o UseCase, Koin lanza excepci√≥n de dependencia no encontrada.

#### Mensaje de error
```
org.koin.core.error.NoBeanDefFoundException: 
No definition found for class:'com.fallapp.user.features.fallas.domain.usecase.GetFallasUseCase'
```

#### Causa ra√≠z
El m√≥dulo Koin no tiene definida la dependencia, o el m√≥dulo no est√° cargado en la aplicaci√≥n.

#### C√≥digo problem√°tico
```kotlin
// AppModule.kt - Falta definici√≥n
val appModule = module {
    // ‚ùå GetFallasUseCase no est√° definido
    viewModel { FallasListViewModel(get()) }
}
```

#### Soluci√≥n
```kotlin
// di/DomainModule.kt
val domainModule = module {
    // Use Cases
    factory { GetFallasUseCase(get()) }
    factory { GetFallaByIdUseCase(get()) }
    factory { SearchFallasUseCase(get()) }
}

// di/DataModule.kt
val dataModule = module {
    // API Services
    single { FallaApiService(get()) }
    
    // DAOs
    single { get<FallAppDatabase>().fallaDao() }
    
    // Repositories
    single<FallaRepository> { FallaRepositoryImpl(get(), get(), get()) }
}

// di/PresentationModule.kt
val presentationModule = module {
    viewModel { FallasListViewModel(get()) }
}

// FallAppApplication.kt
class FallAppApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@FallAppApplication)
            modules(
                networkModule,
                databaseModule,
                dataModule,
                domainModule,      // ‚úÖ Cargar todos los m√≥dulos
                presentationModule
            )
        }
    }
}
```

#### C√≥mo prevenir en el futuro
- Estructura modular: un m√≥dulo por capa (domain, data, presentation)
- Al crear nueva clase inyectable, a√±adirla inmediatamente al m√≥dulo
- Verificar que todos los m√≥dulos est√©n en `startKoin`

---

### ERR-004: Ejemplo - StateFlow no se actualiza en Compose

**Fecha**: 2026-02-01  
**Categor√≠a**: COMPOSE  
**Severidad**: MEDIUM  
**Estado**: üü¢ RESUELTO

#### Descripci√≥n del problema
La UI no se actualiza cuando cambia el estado del ViewModel.

#### Causa ra√≠z
M√∫ltiples causas posibles:
1. No usar `collectAsStateWithLifecycle()`
2. Mutar el estado en lugar de crear nuevo
3. No usar `copy()` en data classes

#### C√≥digo problem√°tico
```kotlin
// ‚ùå Mutando el estado
class FallasViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(FallasUiState())
    val uiState: StateFlow<FallasUiState> = _uiState
    
    fun loadFallas() {
        _uiState.value.fallas = newFallas  // ‚ùå Mutaci√≥n directa
    }
}

// ‚ùå En Compose sin lifecycle
@Composable
fun FallasScreen(viewModel: FallasViewModel) {
    val uiState by viewModel.uiState.collectAsState()  // ‚ùå Sin lifecycle
}
```

#### Soluci√≥n
```kotlin
// ‚úÖ Creando nuevo estado con copy()
class FallasViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(FallasUiState())
    val uiState: StateFlow<FallasUiState> = _uiState.asStateFlow()
    
    fun loadFallas() {
        viewModelScope.launch {
            _uiState.update { currentState ->
                currentState.copy(isLoading = true)
            }
            
            val result = getFallasUseCase()
            
            _uiState.update { currentState ->
                currentState.copy(
                    fallas = result.getOrNull() ?: emptyList(),
                    isLoading = false
                )
            }
        }
    }
}

// ‚úÖ En Compose con lifecycle
@Composable
fun FallasScreen(viewModel: FallasViewModel = koinViewModel()) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    // UI que responde a cambios
}
```

#### C√≥mo prevenir en el futuro
- Siempre usar `copy()` para actualizar data classes
- Siempre usar `collectAsStateWithLifecycle()` en Compose
- Usar `_uiState.update { }` en lugar de `_uiState.value = `

---

### ERR-005: Ejemplo - Ktor SSL Handshake failure

**Fecha**: 2026-02-01  
**Categor√≠a**: NETWORK  
**Severidad**: HIGH  
**Estado**: üü¢ RESUELTO

#### Descripci√≥n del problema
Ktor falla al conectar con servidores HTTPS en ciertos dispositivos.

#### Mensaje de error
```
javax.net.ssl.SSLHandshakeException: 
java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.
```

#### Causa ra√≠z
El certificado SSL del servidor no es reconocido (puede ser self-signed o de una CA no incluida).

#### Soluci√≥n (solo para desarrollo)
```kotlin
// SOLO PARA DESARROLLO - NO USAR EN PRODUCCI√ìN
val httpClient = HttpClient(Android) {
    engine {
        config {
            // Deshabilitar verificaci√≥n SSL (SOLO DESARROLLO)
            if (BuildConfig.DEBUG) {
                sslManager = object : X509TrustManager {
                    override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
                    override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {}
                    override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
                }
            }
        }
    }
}
```

#### Soluci√≥n correcta (producci√≥n)
- Usar certificados SSL v√°lidos (Let's Encrypt)
- Configurar certificate pinning si es necesario

---

## Errores Conocidos Pendientes

### ERR-P001: [T√≠tulo del error pendiente]

**Fecha reportado**: YYYY-MM-DD  
**Categor√≠a**: [CATEGOR√çA]  
**Severidad**: [SEVERIDAD]  
**Estado**: üî¥ ABIERTO

#### Descripci√≥n
[Descripci√≥n del problema]

#### Workaround temporal
[Si existe alg√∫n workaround]

#### Investigaci√≥n
- [ ] Identificar causa ra√≠z
- [ ] Encontrar soluci√≥n
- [ ] Implementar fix
- [ ] Documentar

---

## Patrones de Error Comunes

### 1. Errores de Red

| Error | Causa com√∫n | Soluci√≥n r√°pida |
|-------|-------------|-----------------|
| `UnresolvedHostException` | Sin conexi√≥n a internet | Verificar conectividad, usar NetworkMonitor |
| `SocketTimeoutException` | Servidor lento/ca√≠do | Aumentar timeout, implementar retry |
| `Cleartext not permitted` | HTTP en Android 9+ | Configurar network security |

### 2. Errores de Room

| Error | Causa com√∫n | Soluci√≥n r√°pida |
|-------|-------------|-----------------|
| `Cannot figure out how to save` | Tipo no soportado | A√±adir TypeConverter |
| `Migration required` | Cambio de schema | Crear migraci√≥n o `fallbackToDestructiveMigration()` |
| `Cannot access database on main thread` | Operaci√≥n en UI thread | Usar `withContext(Dispatchers.IO)` |

### 3. Errores de Compose

| Error | Causa com√∫n | Soluci√≥n r√°pida |
|-------|-------------|-----------------|
| UI no actualiza | Mutaci√≥n de estado | Usar `copy()` y `update {}` |
| Recomposition infinita | Side effect en composici√≥n | Usar `LaunchedEffect`, `remember` |
| Leak de contexto | Capturar Context | Usar `LocalContext.current` dentro de Composable |

### 4. Errores de Coroutines

| Error | Causa com√∫n | Soluci√≥n r√°pida |
|-------|-------------|-----------------|
| `Job was cancelled` | ViewModel destruido | Verificar lifecycle |
| `NetworkOnMainThreadException` | Sin dispatcher | Usar `Dispatchers.IO` |
| Leak de coroutine | Scope incorrecto | Usar `viewModelScope` |

---

## üìö Documentos Relacionados

- [00.ARQUITECTURA-MOBILE.md](00.ARQUITECTURA-MOBILE.md) - Arquitectura general
- [03.PROMPT-GENERACION-IA.md](03.PROMPT-GENERACION-IA.md) - Prompts para IA
- [../../04.docs/01.GUIA-PROGRAMACION.md](../../04.docs/01.GUIA-PROGRAMACION.md) - Gu√≠a de programaci√≥n

---

> **Recuerda**: Cada error documentado ahorra tiempo en el futuro.
> Si encuentras un error, ¬°docum√©ntalo!
