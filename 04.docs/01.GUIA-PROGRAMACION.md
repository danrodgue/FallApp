# GuÃ­a de ProgramaciÃ³n - FallApp

> **Documento canÃ³nico** para desarrolladores humanos e IAs.  
> Ãšltima actualizaciÃ³n: 2026-02-01

---

## ðŸ“‹ Ãndice

1. [FilosofÃ­a y Contexto](#filosofÃ­a-y-contexto)
2. [Principios de DiseÃ±o](#principios-de-diseÃ±o)
3. [Estructura del Proyecto](#estructura-del-proyecto)
4. [Convenciones de CÃ³digo](#convenciones-de-cÃ³digo)
5. [Patrones de Desarrollo](#patrones-de-desarrollo)
6. [GuÃ­as para IAs](#guÃ­as-para-ias)
7. [Lista de VerificaciÃ³n](#lista-de-verificaciÃ³n)
8. [Errores Comunes](#errores-comunes)

---

## 1. FilosofÃ­a y Contexto

### QuiÃ©nes Somos
Proyecto acadÃ©mico intermodular con **4 semanas de desarrollo**. Prioridad absoluta en velocidad de entrega y funcionalidad completa sobre arquitecturas complejas.

### Principio Rector
> **Simplicidad ahora, evoluciÃ³n despuÃ©s.**
> No sobreingenierÃ­a. CÃ³digo que funciona > CÃ³digo perfecto.

### Objetivos del Proyecto
- âœ… **Funcional**: Sistema completo API + Escritorio + MÃ³vil
- âœ… **Probado**: ~100 pruebas automatizadas (humo + integraciÃ³n)
- âœ… **Desplegable**: Docker + EC2 funcionando
- âœ… **Documentado**: Specs claras para cada mÃ³dulo
- âœ… **Demostrable**: Listo para presentaciÃ³n ante tribunal

### Compromisos Aceptados
| Priorizamos... | Sobre... |
|---------------|----------|
| Velocidad de desarrollo | Arquitectura perfecta |
| Funcionalidad completa | OptimizaciÃ³n prematura |
| CÃ³digo explÃ­cito | Abstracciones complejas |
| Pruebas de integraciÃ³n | Cobertura 100% |
| DocumentaciÃ³n tÃ©cnica | DocumentaciÃ³n exhaustiva |

---

## 2. Principios de DiseÃ±o

### KISS (Keep It Simple, Stupid)
- SoluciÃ³n mÃ¡s directa siempre gana
- Si tiene >150 lÃ­neas, considerar dividir
- Preferir cÃ³digo legible sobre cÃ³digo "elegante"

### DRY (Don't Repeat Yourself) con LÃ­mites
- **3+ copias de cÃ³digo** â†’ Refactorizar y centralizar
- **1-2 copias** â†’ Aceptable en fase inicial
- Crear utilidades compartidas cuando el patrÃ³n estÃ© claro

### Fail-Fast: Fallos ExplÃ­citos

**Principio fundamental**: Preferimos errores tempranos y claros sobre comportamientos inesperados.

#### MotivaciÃ³n
- **Desarrollo rÃ¡pido**: Los errores explÃ­citos se detectan inmediatamente
- **Debug sencillo**: Un error claro es mÃ¡s fÃ¡cil de resolver
- **Menos cÃ³digo**: Sin lÃ³gica de fallback compleja
- **Mantenimiento**: CÃ³digo mÃ¡s predecible

#### Reglas
1. **NO usar valores por defecto silenciosos**
   ```java
   // âŒ MAL - Oculta configuraciÃ³n faltante
   String apiUrl = config.getApiUrl().orElse("http://localhost:8080");
   
   // âœ… BIEN - Falla si no estÃ¡ configurado
   String apiUrl = config.getApiUrl()
       .orElseThrow(() -> new ConfigurationException("API URL no configurada"));
   ```

2. **Validar parÃ¡metros estrictamente**
   ```java
   public void crearEvento(Long fallaId, String nombre) {
       Objects.requireNonNull(fallaId, "fallaId no puede ser null");
       Objects.requireNonNull(nombre, "nombre no puede ser null");
       if (nombre.isBlank()) {
           throw new IllegalArgumentException("nombre no puede estar vacÃ­o");
       }
       // ... lÃ³gica
   }
   ```

3. **Fallar con contexto Ãºtil**
   ```java
   if (!casalRepository.existsById(casalId)) {
       throw new EntityNotFoundException(
           String.format("Casal con ID %d no existe", casalId)
       );
   }
   ```

4. **Las pruebas detectan configuraciones rotas**
   - Pruebas de humo verifican configuraciÃ³n bÃ¡sica
   - En desarrollo: es mejor que falle el arranque que comportamiento extraÃ±o

#### Excepciones VÃ¡lidas
Los valores por defecto son aceptables cuando:
- UI/UX (texto alternativo, imagen placeholder)
- Valores verdaderamente opcionales y documentados
- No ocultan errores de configuraciÃ³n

### Explicit Over Implicit
- Variables de entorno documentadas en `application.properties`
- Nombres de clases/mÃ©todos autoexplicativos
- Logs claros con contexto suficiente

---

## 3. Estructura del Proyecto

### Backend (Spring Boot)
```
fallapp-backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/com/fallapp/
â”‚   â”‚   â”‚   â”œâ”€â”€ FallAppApplication.java
â”‚   â”‚   â”‚   â”œâ”€â”€ config/              # ConfiguraciÃ³n (Security, CORS, etc.)
â”‚   â”‚   â”‚   â”œâ”€â”€ controller/          # Endpoints REST
â”‚   â”‚   â”‚   â”œâ”€â”€ service/             # LÃ³gica de negocio
â”‚   â”‚   â”‚   â”œâ”€â”€ repository/          # Acceso a datos (JPA)
â”‚   â”‚   â”‚   â”œâ”€â”€ model/               # Entidades JPA
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/                 # DTOs para API
â”‚   â”‚   â”‚   â”œâ”€â”€ exception/           # Excepciones personalizadas
â”‚   â”‚   â”‚   â””â”€â”€ util/                # Utilidades
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚       â”œâ”€â”€ application.properties
â”‚   â”‚       â”œâ”€â”€ application-dev.properties
â”‚   â”‚       â”œâ”€â”€ application-prod.properties
â”‚   â”‚       â””â”€â”€ db/migration/        # Migraciones SQL (Flyway)
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/com/fallapp/
â”‚           â”œâ”€â”€ integration/         # Pruebas de integraciÃ³n
â”‚           â””â”€â”€ smoke/               # Pruebas de humo
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ pom.xml                          # Dependencias Maven
â””â”€â”€ README.md
```

### Frontend Escritorio (Electron)
```
fallapp-desktop/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.js                      # Proceso principal Electron
â”‚   â”œâ”€â”€ preload.js                   # Script de precarga
â”‚   â”œâ”€â”€ renderer/
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â”‚   â””â”€â”€ main.css
â”‚   â”‚   â””â”€â”€ scripts/
â”‚   â”‚       â”œâ”€â”€ api.js               # Cliente API
â”‚   â”‚       â”œâ”€â”€ auth.js              # AutenticaciÃ³n
â”‚   â”‚       â””â”€â”€ main.js
â”‚   â””â”€â”€ assets/
â”‚       â””â”€â”€ images/
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

### AplicaciÃ³n MÃ³vil (Android)
```
fallapp-android/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”‚   â”œâ”€â”€ java/com/fallapp/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ data/            # Repositorios, BD Room
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ domain/          # Casos de uso
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ presentation/    # UI (Activities, Fragments, ViewModels)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ di/              # InyecciÃ³n de dependencias
â”‚   â”‚   â”‚   â”œâ”€â”€ res/                 # Recursos (layouts, strings, etc.)
â”‚   â”‚   â”‚   â””â”€â”€ AndroidManifest.xml
â”‚   â”‚   â””â”€â”€ test/
â”‚   â””â”€â”€ build.gradle
â”œâ”€â”€ build.gradle
â””â”€â”€ settings.gradle
```

---

## 4. Convenciones de CÃ³digo

### Java (Backend Spring Boot)

#### Nomenclatura
```java
// Clases: PascalCase
public class EventoService { }

// MÃ©todos: camelCase (verbos)
public Evento crearEvento() { }
public List<Evento> listarEventos() { }

// Constantes: UPPER_SNAKE_CASE
public static final int MAX_EVENTOS_POR_FALLA = 50;

// Variables: camelCase (sustantivos descriptivos)
private Long fallaId;
private String nombreEvento;
```

#### Estructura de Clases
```java
@Service
public class EventoService {
    // 1. Constantes
    private static final Logger log = LoggerFactory.getLogger(EventoService.class);
    
    // 2. Dependencias inyectadas
    private final EventoRepository eventoRepository;
    private final FallaRepository fallaRepository;
    
    // 3. Constructor
    public EventoService(EventoRepository eventoRepository, 
                         FallaRepository fallaRepository) {
        this.eventoRepository = eventoRepository;
        this.fallaRepository = fallaRepository;
    }
    
    // 4. MÃ©todos pÃºblicos
    public EventoDTO crearEvento(CrearEventoRequest request) {
        // ValidaciÃ³n
        validarRequest(request);
        
        // LÃ³gica de negocio
        Evento evento = construirEvento(request);
        Evento guardado = eventoRepository.save(evento);
        
        // Logging
        log.info("Evento creado: id={}, nombre={}", guardado.getId(), guardado.getNombre());
        
        return convertirADTO(guardado);
    }
    
    // 5. MÃ©todos privados
    private void validarRequest(CrearEventoRequest request) {
        // ... validaciÃ³n
    }
}
```

#### Controladores REST
```java
@RestController
@RequestMapping("/api/eventos")
public class EventoController {
    
    private final EventoService eventoService;
    
    @PostMapping
    public ResponseEntity<EventoDTO> crear(@Valid @RequestBody CrearEventoRequest request) {
        EventoDTO evento = eventoService.crearEvento(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(evento);
    }
    
    @GetMapping
    public ResponseEntity<List<EventoDTO>> listar(
            @RequestParam(required = false) Long fallaId) {
        List<EventoDTO> eventos = eventoService.listarEventos(fallaId);
        return ResponseEntity.ok(eventos);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<EventoDTO> obtenerPorId(@PathVariable Long id) {
        EventoDTO evento = eventoService.obtenerPorId(id);
        return ResponseEntity.ok(evento);
    }
}
```

### JavaScript (Electron)

#### Nomenclatura
```javascript
// Variables: camelCase
const apiBaseUrl = 'http://localhost:8080/api';
let usuarioActual = null;

// Constantes: UPPER_SNAKE_CASE o camelCase
const API_TIMEOUT = 5000;

// Funciones: camelCase (verbos)
async function autenticarUsuario(email, password) { }
function mostrarError(mensaje) { }

// Clases: PascalCase
class ApiClient { }
```

#### Manejo de Promesas
```javascript
// âœ… BIEN - async/await
async function cargarEventos(fallaId) {
    try {
        const response = await fetch(`${API_URL}/eventos?fallaId=${fallaId}`);
        if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
        }
        const eventos = await response.json();
        return eventos;
    } catch (error) {
        console.error('Error cargando eventos:', error);
        mostrarError('No se pudieron cargar los eventos');
        throw error;
    }
}

// âŒ MAL - Callback hell
function cargarEventos(fallaId, callback) {
    fetch(`${API_URL}/eventos?fallaId=${fallaId}`)
        .then(response => response.json())
        .then(data => callback(null, data))
        .catch(error => callback(error));
}
```

### Kotlin (Android)

#### Nomenclatura
```kotlin
// Clases: PascalCase
class EventoRepository { }

// Funciones: camelCase
suspend fun obtenerEventos(): List<Evento> { }

// Propiedades: camelCase
private val eventoDao: EventoDao
val eventos: LiveData<List<Evento>>

// Constantes: UPPER_SNAKE_CASE (en companion object)
companion object {
    const val MAX_REINTENTOS = 3
    private const val TAG = "EventoRepository"
}
```

#### Corrutinas
```kotlin
// âœ… BIEN - viewModelScope
class EventosViewModel(
    private val repository: EventoRepository
) : ViewModel() {
    
    private val _eventos = MutableStateFlow<List<Evento>>(emptyList())
    val eventos: StateFlow<List<Evento>> = _eventos.asStateFlow()
    
    fun cargarEventos() {
        viewModelScope.launch {
            try {
                val resultado = repository.obtenerEventos()
                _eventos.value = resultado
            } catch (e: Exception) {
                Log.e(TAG, "Error cargando eventos", e)
                // Manejar error
            }
        }
    }
}
```

---

## 5. Patrones de Desarrollo

### API REST - Estructura de Respuestas

#### Respuesta Exitosa
```json
{
  "id": 123,
  "nombre": "PlantÃ  2026",
  "descripcion": "PlantÃ  de la falla mayor",
  "fecha": "2026-03-15T10:00:00Z",
  "fallaId": 45
}
```

#### Respuesta con Lista
```json
{
  "contenido": [
    { "id": 1, "nombre": "..." },
    { "id": 2, "nombre": "..." }
  ],
  "total": 25,
  "pagina": 0,
  "tamanoPagina": 10
}
```

#### Respuesta de Error
```json
{
  "timestamp": "2026-02-01T14:30:00Z",
  "estado": 400,
  "error": "Bad Request",
  "mensaje": "El nombre del evento no puede estar vacÃ­o",
  "ruta": "/api/eventos"
}
```

### Manejo de Errores

#### Backend (Spring)
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> manejarNoEncontrado(
            EntityNotFoundException ex, WebRequest request) {
        
        ErrorResponse error = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.NOT_FOUND.value(),
            "Not Found",
            ex.getMessage(),
            request.getDescription(false).replace("uri=", "")
        );
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> manejarArgumentoInvalido(
            IllegalArgumentException ex, WebRequest request) {
        
        ErrorResponse error = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.BAD_REQUEST.value(),
            "Bad Request",
            ex.getMessage(),
            request.getDescription(false).replace("uri=", "")
        );
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
}
```

#### Frontend (Electron)
```javascript
async function guardarEvento(evento) {
    try {
        const response = await fetch(`${API_URL}/eventos`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getToken()}`
            },
            body: JSON.stringify(evento)
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.mensaje || 'Error guardando evento');
        }
        
        return await response.json();
        
    } catch (error) {
        console.error('Error en guardarEvento:', error);
        mostrarNotificacion('error', error.message);
        throw error;
    }
}
```

### AutenticaciÃ³n y AutorizaciÃ³n

#### Backend - ConfiguraciÃ³n Spring Security
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/fallas/**").permitAll() // Lectura pÃºblica
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

#### Frontend - Almacenar Token
```javascript
// âœ… BIEN - Almacenamiento seguro en Electron
const Store = require('electron-store');
const store = new Store({ encryptionKey: 'tu-clave-secreta' });

function guardarToken(token) {
    store.set('authToken', token);
}

function obtenerToken() {
    return store.get('authToken');
}

function cerrarSesion() {
    store.delete('authToken');
}
```

---

## 6. GuÃ­as para IAs

### Contexto Necesario
Antes de implementar cualquier funcionalidad, la IA debe:

1. **Leer el Ã­ndice**: `00.INDICE.md`
2. **Leer la visiÃ³n general**: `especificaciones/00.VISION-GENERAL.md`
3. **Leer la especificaciÃ³n relevante**: e.g., `especificaciones/02.FALLAS.md`
4. **Entender el stack**: Spring + PostgreSQL + Electron + Android

### Patrones de ImplementaciÃ³n

#### Crear Nueva Entidad
1. Crear clase entidad JPA en `model/`
2. Crear repositorio en `repository/`
3. Crear servicio en `service/`
4. Crear controlador en `controller/`
5. Crear DTOs en `dto/`
6. Crear migraciÃ³n SQL en `resources/db/migration/`
7. AÃ±adir pruebas en `test/`

#### Crear Nuevo Endpoint
1. Verificar especificaciÃ³n del endpoint
2. AÃ±adir mÃ©todo en controlador
3. Implementar lÃ³gica en servicio
4. Actualizar/crear DTOs si es necesario
5. AÃ±adir validaciones
6. AÃ±adir prueba de integraciÃ³n

### Verificaciones AutomÃ¡ticas
DespuÃ©s de cada cambio, la IA debe considerar:

- âœ… Â¿El cÃ³digo compila sin errores?
- âœ… Â¿Las pruebas existentes siguen pasando?
- âœ… Â¿Se aÃ±adieron pruebas para la nueva funcionalidad?
- âœ… Â¿El cÃ³digo sigue las convenciones de nomenclatura?
- âœ… Â¿Se actualizÃ³ la documentaciÃ³n si fue necesario?

---

## 7. Lista de VerificaciÃ³n

### Antes de Implementar
- [ ] He leÃ­do la especificaciÃ³n relacionada
- [ ] Entiendo el objetivo de la funcionalidad
- [ ] SÃ© quÃ© tablas/entidades estÃ¡n involucradas
- [ ] Tengo claro el flujo de datos

### Durante la ImplementaciÃ³n
- [ ] Sigo las convenciones de nomenclatura
- [ ] Uso fail-fast para validaciones
- [ ] AÃ±ado logs informativos (no excesivos)
- [ ] Manejo errores explÃ­citamente
- [ ] El cÃ³digo es legible sin comentarios

### DespuÃ©s de Implementar
- [ ] El cÃ³digo compila
- [ ] Las pruebas pasan
- [ ] AÃ±adÃ­ pruebas para la nueva funcionalidad
- [ ] ProbÃ© manualmente el flujo completo
- [ ] ActualicÃ© la documentaciÃ³n si fue necesario

### Antes de Commit
- [ ] RevisÃ© los cambios (git diff)
- [ ] Mensaje de commit descriptivo
- [ ] No hay cÃ³digo comentado innecesario
- [ ] No hay console.log / System.out.println olvidados

---

## 8. Errores Comunes

### Backend

#### âŒ Error: Entidad no guarda cambios
```java
// MAL
public void actualizarNombre(Long id, String nuevoNombre) {
    Falla falla = fallaRepository.findById(id).orElseThrow();
    falla.setNombre(nuevoNombre);
    // âŒ Falta guardar
}

// BIEN
public void actualizarNombre(Long id, String nuevoNombre) {
    Falla falla = fallaRepository.findById(id).orElseThrow();
    falla.setNombre(nuevoNombre);
    fallaRepository.save(falla); // âœ…
}
```

#### âŒ Error: NullPointerException
```java
// MAL
public EventoDTO obtenerEvento(Long id) {
    Evento evento = eventoRepository.findById(id).get(); // âŒ Puede lanzar NoSuchElementException
    return convertirADTO(evento);
}

// BIEN
public EventoDTO obtenerEvento(Long id) {
    Evento evento = eventoRepository.findById(id)
        .orElseThrow(() -> new EntityNotFoundException("Evento no encontrado: " + id));
    return convertirADTO(evento);
}
```

### Frontend

#### âŒ Error: CORS
Si aparece error CORS en frontend:
1. Verificar configuraciÃ³n en backend:
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000") // Ajustar segÃºn entorno
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
```

#### âŒ Error: No se actualiza la UI
```javascript
// MAL - Modificar array directamente
function agregarEvento(nuevoEvento) {
    eventos.push(nuevoEvento); // âŒ No reactivo
}

// BIEN - Crear nuevo array
function agregarEvento(nuevoEvento) {
    eventos = [...eventos, nuevoEvento]; // âœ… Reactivo
}
```

---

## ðŸ”„ ActualizaciÃ³n de Esta GuÃ­a

Esta guÃ­a debe actualizarse cuando:
- Se toman decisiones arquitectÃ³nicas importantes
- Se detectan patrones que se repiten
- Se resuelven problemas complejos
- Se aÃ±aden nuevas tecnologÃ­as/librerÃ­as

**Responsabilidad**: Todo el equipo. Si encuentras algo confuso o falta documentaciÃ³n, aÃ±Ã¡delo.

---

> ðŸ’¡ **Recuerda**: Esta guÃ­a es una herramienta viva. Ãšsala, mejÃ³rala, compÃ¡rtela.
